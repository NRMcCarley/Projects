# -*- coding: utf-8 -*-
"""Simple GAN 2.0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J2KAzZcxRQRfCVkBzXjwvRTILHFROeO7

# **Import Statements**
"""

import numpy as np
from numpy import random
import matplotlib.pyplot as plt
import pandas as pd

"""# **Functions**"""

def sigmoid(x):
  return 1/(1+np.exp(-1*x))

def sigmoid_prime(x):
  return sigmoid(x)*(1-sigmoid(x))

def init_params(n):
  Wd = np.random.rand(1, n*n)
  bd = np.random.rand(1, 1)
  Wg = np.random.rand(n*n, 1)
  bg = np.random.rand(n*n, 1)
  return Wd, bd, Wg, bg

def disc_forward_prop(X, Wd, bd):
  Zd = np.dot(Wd, X) + bd
  Ad = sigmoid(Zd)
  return Ad, Zd

def gen_forward_prop(Wg, bg):
  Z = np.random.rand(n*n, 1)
  Zg = np.multiply(Z, Wg) + bg
  Ag = sigmoid(Zg)
  return Ag, Zg, Z

def disc_backprop_real(X, Ad):
  dWd = (Ad - 1) * X.T
  dbd = (Ad - 1)
  return dWd, dbd

def disc_backprop_fake(X, Ad):
  dWd = Ad * X.T
  dbd = Ad
  return dWd, dbd

def gen_backprop(Ad, Wd, Zg, z):
  dWg = (Ad - 1) * np.multiply(np.multiply(Wd.T, sigmoid_prime(Zg)), z)
  dbg = (Ad - 1) * np.multiply(Wd.T, sigmoid_prime(Zg))
  return dWg, dbg

"""# **Target Image**"""

square = np.array([[1, 1, 1, 1],
                   [1, 0, 0, 1],
                   [1, 0, 0, 1],
                   [1, 1, 1, 1]])
n = np.shape(square)[0]
real_img_data = np.reshape(square, (n*n, 1))
plt.imshow(square, cmap="Greys")
plt.title("Real Image")
plt.show()

"""# **Main Loop**"""

Wd, bd, Wg, bg = init_params(n)
alpha = 0.05
gamma = 0.5
iters = 1000
iter = 0
Z_set_seed = np.random.rand(n*n, 1)
seed_imgs = np.zeros((iters, n, n))
EdReal = np.zeros((iters))
EdFake = np.zeros((iters))
EgRight = np.zeros((iters))
EgWrong = np.zeros((iters))
DsReal = np.zeros((iters))
DsFake = np.zeros((iters))
# Iterate through model updates
while iter < iters:
  # Train Discriminator on real image
  X = real_img_data
  Ad, Zd = disc_forward_prop(X, Wd, bd)
  dWd, dbd = disc_backprop_real(X, Ad)
  Wd -= alpha * dWd
  bd -= alpha * dbd
  EdReal[iter] = -1*np.log(Ad) # Discriminator error
  DsReal[iter] = Ad[0,0] # Discriminator score
  # Train discriminator on fake image
  Ag, Zg, Z = gen_forward_prop(Wg, bg)
  Ad, Zd = disc_forward_prop(Ag, Wd, bd)
  EdFake[iter] = -1*np.log(1 - Ad) # Discriminator error
  DsFake[iter] = Ad[0,0] # Discriminator score
  seed_imgs[iter,:,:] = np.reshape(sigmoid(np.multiply(Z_set_seed, Wg) + bg), (n, n))
  if Ad > gamma:
    dWd, dbd = disc_backprop_fake(Ag, Ad)
    Wd -= alpha * dWd
    bd -= alpha * dbd
    EgWrong[iter] = -1 * np.log(Ad) # Generator error
    iter += 1
  else:
    dWg, dbg = gen_backprop(Ad, Wd, Zg, Z)
    Wg -= dWg
    bg -= dbg
    EgRight[iter] = -1 * np.log(Ad) # Generator error
    iter += 1

xs1 = np.arange(0,iters)
plt.plot(xs1, EdReal, '.',label='Real Image')
plt.plot(xs1, EdFake, '.',label='Fake Image')
plt.title("Discriminator Error")
plt.xlabel('Iteration')
plt.ylabel('Error')
plt.legend()
plt.show()

xs = np.arange(0,iters,0.5)
plt.plot(xs1,DsReal,'.',label='Real Image')
plt.plot(xs1,DsFake,'.',label='Fake Image')
plt.title("Discriminator Scores")
plt.xlabel('Iteration')
plt.ylabel('Score')
plt.legend()
plt.show()

xs2 = np.arange(iters)
plt.plot(xs1,EgRight,'.',label='Discriminator Right')
plt.plot(xs1,EgWrong,'.',label='Discriminator Wrong')
plt.title("Generator Error")
plt.xlabel('Iteration')
plt.ylabel('Error')
plt.legend()
plt.show()

Ag, Zg, Z = gen_forward_prop(Wg, bg)
Ad, Zd = disc_forward_prop(Ag, Wd, bd)
x = pd.DataFrame(np.reshape(Ag, (n,n)))
# display(x)
plt.imshow(np.reshape(Ag, (n,n)), cmap="Greys")
plt.title("Generated Image")
plt.show()
print(f"Discriminator Score: {Ad[0,0]}")
x=pd.DataFrame(np.reshape(Ag, (n,n)))
display(x)

"""# **Observing Learning**"""

seed_freq = 20
i = 0
while i < iters:
  if i % seed_freq == 0:
    plt.imshow(seed_imgs[i,:,:], cmap='Greys', vmin=0, vmax=1)
    plt.title(f"Iteration: {i}")
    plt.show()
    i += 1
  else:
    i += 1

!pip install -q moviepy
!apt install imagemagick
!pip install imageio==2.4.1

import numpy as np
a, b, c = np.shape(seed_imgs)
frames = np.reshape(seed_imgs, (a, b, c, 1))*-255  # YOUR DATA HERE
# frames2 = np.random.randint(256, size=[20, 64, 64, 1], dtype=np.uint8)  # YOUR DATA HERE

# save it as a gif
from moviepy.editor import ImageSequenceClip
clip = ImageSequenceClip(list(frames), fps=10000)
clip = clip.resize((40,40))
clip.write_gif('test.gif', fps=10000)

from IPython.display import display, Image
Image('test.gif')